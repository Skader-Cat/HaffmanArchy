#include "Code.h"
using namespace std;

int main() {
	setlocale(0, "rus");
	bool flag = false;
	int size_of_simbs; //исходный размер словаря. То есть сколько всего уникальных символов в файле
	string path = get_path(); //получаем путь
	fstream file;
	file = get_file(path); //инициализируем и проверяем(нет) файл
	list<elem> tree = make_sluzheb_info(file, path, &size_of_simbs); //создаем дерево из данных файла
	//дальше по-хорошему надо было бы написать функцию создания дерева, но пока так. Особо много места не занимает и не теряется!
	for (int i = 0; i < size_of_simbs-1; i++) { //не знаю, правильно ли это, но я заметил, что в оптимальном построении дерева всегда на одну операцию меньше, чем кол-во
		//символов
		make_node(&tree, size_of_simbs); //создаю узел
	}
	//Дальше уже просто мусорная отладка. Решил проверить, реально ли между собой соединены элементы
	list<elem>::iterator it = tree.end();
	it--;
	//Рекурсию придумали в 30г до нашей эры
	//Люди до этого xddxdxdx:
	cout << "Корень дерева: " << it->simb << endl;
	cout << "Левый родитель: " << it->l->simb << endl;
	cout << "Правый родитель: " << it->r->simb << endl;
	cout << "Левый родитель левого родителя: " << it->l->l->simb << endl;
	cout << "Правый родитель левого родителя: " << it->l->r->simb << endl;
};

